[![pipeline status](https://gitlab.com/tirava/image-previewer/badges/master/pipeline.svg)](https://gitlab.com/tirava/image-previewer/commits/master)
[![coverage report](https://gitlab.com/tirava/image-previewer/badges/master/coverage.svg)](https://gitlab.com/tirava/image-previewer/commits/master)

## Запуск / остановка микросервиса через Docker-compose
`make up` / `make down`

## Запуск интеграционных тестов микросервиса через Docker-compose
`make test`

# ТЗ на сервис "Превьювер изображений"

## Общее описание
Сервис предназначен для изготовления preview (создания изображения
с новыми размерами на основе имеющегося изображения).
#### Пример превьюшек в папке examples (./examples)

## Архитектура
Сервис представляет собой web-сервер (прокси), загружающий изображения,
масштабирующий/обрезающий их до нужного формата и возвращающий пользователю.

## Основной обработчик
https://cut-service.com/fill/300/200/www.audubon.org/sites/default/files/a1_1902_16_barred-owl_sandra_rothenberg_kk.jpg

<---- микросервис ----><- размеры превью -><--------- URL исходного изображения --------------------------------->

В URL выше мы видим:
- https://cut-service.com/fill/300/200/ - endpoint нашего сервиса,
в котором 300x200 - это размеры финального изображения.
- www.audubon.org/sites/default/files/a1_1902_16_barred-owl_sandra_rothenberg_kk.jpg - 
адрес исходного изображения; сервис должен скачать его, произвести resize, закэшировать и отдать клиенту.

Сервис должен получить URL исходного изображения, скачать его, изменить до необходимых размеров и вернуть как HTTP-ответ.

**Важно**: необходимо проксировать все заголовки исходного HTTP запроса к целевому сервису (www.audubon.org в примере).

Сервис должен сохранить (кэшировать) полученное preview на локальном диске и при повторном запросе
отдавать изображение с диска, без запроса к удаленному HTTP-серверу.

Поскольку размер места для кэширования ограничен, то для удаления редко используемых изображений
необходимо использовать алгоритм **"Least Recent Used"**.

## Конфигурация
Основной параметр конфигурации сервиса - разрешенный размер LRU-кэша.

## Развертывание
Развертывание микросервиса должно осуществляться командой `make run` (внутри `docker compose up`)
в директории с проектом.

## Тестирование
Реализацию алгоритма LRU нужно покрыть unit-тестами.

Для интеграционного тестирования можно использовать контейнер с Nginx в качестве удаленного HTTP-сервера,
раздающего вам заданный набор изображений.

Необходимо проверить работу сервера в разных сценариях:
* картинка найдена в кэше;
* удаленный сервер не существует;
* удаленный сервер существует, но изображение не найдено (404 Not Found);
* удаленный сервер существует, но изображение не изображение, а скажем, exe-файл;
* удаленный сервер вернул ошибку;
* удаленный сервер вернул изображение;
* изображение меньше, чем нужный размер;
и пр.

## Разбалловка
Максимум - **10 баллов**
(при условии выполнения [обязательных требований](./README.md)):

* Реализован HTTP-сервер, проксирующий запросы к удаленному серверу - 1 балл.
* Реализована нарезка изображений - 1 балл.
* Кэширование нарезанных изображений на диске - 1 балл.
* Ограничение кэша по месту (LRU кэш) - 1 балл.
* Прокси сервер правильно передает заголовки запроса и ответа - 1 балл.
* Сервис не протекает по памяти - 1 балл.
* Написаны интеграционные тесты - 2 балла.
* Тесты адекватны и полностью покрывают фукнционал - 1 балл.
* Проект возможно собрать чере `make build`, запустить через `make run`
  и протестировать через `make test` - 1 балл.

## Дополнительные требования
* Наличие юнит-тестов на ключевые алгоритмы (ядро) сервиса.
* Докеризация сервиса:
    - наличие валидного Dockerfile для сервиса;
    - сервис и необходимое ему окружение запускаются без ошибок через `make run` (внутри `docker compose up`) в корне проекта,
    при этом все нужные для работы с сервисом порты доступны с хоста.
* Ветка master успешно проходит пайплайн в CI-CD системе (на ваш вкус, Circle CI, Travis CI, Jenkins, GitLab CI и пр.).
**Пайплайн должен в себе содержать**:
    - запуск `go fmt` и проверку, что команда ничего не возвращает (все файлы уже отформатированы);
    - запуск `go vet`;
    - запуск последней версии `golangci-lint` на весь проект с флагом `--enable-all`;
    - запуск `go test` и `go test -race`;
    - сборку бинаря сервиса для версии Go не ниже 1.12. 

При невыполнении хотя бы одного из требований выше - максимальная оценка за проект **4 из 10 баллов**,
несмотря на, например, полностью написанный код сервиса.

### Использование сторонних библиотек
Допускается, но:
- вы должны иметь представление о том, что происходит внутри.
- точно ли подходит данная библиотека для решения вашей задачи?
- не станет ли библиотека узким местом сервиса?
- не полезнее ли написать функционал, которые вы хотите получить от библиотеки, самому?

---

Для упрощения проверки вашего репозитория, рекомендуем использовать значки GitHub
([GitHub badges](https://github.com/dwyl/repo-badges)), а также [Go Report Card](https://goreportcard.com/).
